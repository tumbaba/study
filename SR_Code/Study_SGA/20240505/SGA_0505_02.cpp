
// ──────────────────────────────────────────014 #include 배우기 ──────────────────────────────────────────

#include "stdafx.h"		// 1 #include "파일이름" = 사용자가 만든 다른 파일을 참조할때 사용
#include <vector>		// 2 #include <파일이름> = c++ 에서 제공하는 기본 라이브러리를 사용
//						   
/*
int main() {
	vector<int> exam;
	exam.push_back(10);
	exam.push_back(20);
	exam.push_back(30);

	for (int i = 0, size = exam.size(); i < size; i++) {
		cout << "백터 값 : " << exam.at(i) << endl;
	}


	return 0;
}
*/
// ──────────────────────────────────────────015 스코핑룰 이해하기 ──────────────────────────────────────────
/*
int x = 10;
int func1() 
{
	int y = x + 10;
	return y;
}
int func2() 
{
	int x = 100;
	return x;
}

int main() {

	cout << "y = " << func1() << endl;      // 20
	cout << "x = " << func2() << endl;		// 100
	cout << "x = " << x << endl;			// 10
	// 같은 이름의 변수라도 영역에 따라 값이 달라질 수 있다. 변수가 유효한 공간이 존재하는데 이 영역을 scope라고 한다.
	// 전역변수 x로 사용된 내용 참고.

	return 0;
}
*/
// ──────────────────────────────────────────018 정수형 변수 ──────────────────────────────────────────
// int = 정수 
// 자료형 범위 = -2,147,483,648 ~ +2,147,483,647
// unsigned int = 0 ~ 4,294,967,295
// 아스키코드 A = 65
// 변수는 char < short < int < long < long long 순서로 byte 크기가 커짐
// 실수형 변수 중 double = 8바이트 (소수점 15자리)
// 실수형 변수 중 float = 4바이트 (소수점 7자리)

// ──────────────────────────────────────────020 논리형 변수(bool) ──────────────────────────────────────────
/*
int main() {
	int x = 10;
	int y = 6;

	bool is_true = false; // bool 변수 선언 folse는 일반적 조건에서 "맞다"는 것을 유추하기 위함으로 사용되므로 초반 false로 선언
	
	if (x > y) 
	{
		is_true = true;
	}
	else
	{
		is_true = false;
	}
	//true는 정수 1, false는 정수 0값을 갖게된다.
	// 위에는 x와 y의 크기를 비교

	if (is_true == true)
	{
		cout << "x는 y보다 큽니다" << endl;
	}
	else
	{
		cout << "x는 y보다 작습니다" << endl;
	}
	// 위의 비교되어 나온 결과값을 통해 또다시 비교하여 출력

	return 0;
}
*/

// ──────────────────────────────────────────023 증감연산자──────────────────────────────────────────
/*
int main() {

	int x = 1;
	cout << "x = " << x++ << endl;			// 1     x=1을 먼저 사용하고 그다음에 +1이 붙기 때문에 그대로 출력
	cout << "x = " << x++ << endl;			// 2     위에 먼저 1 나타냈고 더한값 출력
	cout << "x = " << ++x << endl;			// 4     ++가 앞에 오게 된다면 먼저 1을 증가한 뒤 출력됨
	cout << "x = " << x-- << endl;			// 4	 현재 값 나타내고 그다음에 -1 붙기 때문에 그대로 출력
	cout << "x = " << x-- << endl;			// 3	
	cout << "x = " << --x << endl;			// 1	 --가 앞에 오게 된다면 먼저 1을 감소한 뒤 출력
	
	return 0;
}
*/
// ──────────────────────────────────────────029 캐스트 연산자(static_cast)──────────────────────────────────────────
/*
int main() {

	int x = 2;									//정수형 변수 선언
	double y = 4.4;								//실수형 변수 선언

	int i = static_cast<int>(y / x);			// i에 4.4 / 2를 저장하지만 int(정수)에 double(실수)를 저장할 수 없어서 결과가 2 나타남. 이때 static_cast를 통해 int로 정식 변환해야함
	int j = (int)y / x;							// C언어 스타일 캐스팅이나 가급적 c++에서 사용하지 말것.
	double k = y / x;							// k는 소수점 저장이 가능햐여 캐스팅 하지않고 결과값 나타냄

	cout << "4.4 / 2 = (static_cast<int>) " << i << endl;
	cout << "4.4 / 2 = (int) " << j << endl;
	cout << "4.4 / 2 = " << k << endl;

	// -------------캐스트 4가지 방법은 간단히 아래아 같음--------------
	// static_cast<> : 가장 기본적인 캐스트 연산방법
	// dynamic_cast<> : 객체지향 언어의 다형성을 이용하여 모호한 타입 캐스팅 오류를 막아줌
	// const_cast<> : 자료형이 갖고있는 상수 속성을 제거
	// reinterpret_cast<> : 어떠한 포인터 타입끼리도 변환할 수 있게 도움

	return 0;
}
*/

// ──────────────────────────────────────────036 순환문으로 홀수 짝수 찾기(for)──────────────────────────────────────────
/*
int main() { 
	
	int data[10] = { 5, 19, 76, 3, 10, 89, 54, 43, 2, 17 };

	for (int i = 0; i < 10; i++)
	{
		if (data[i] % 2 == 0)
			cout << i << " : " << data[i] << "는 짝수 입니다." << endl;
		else
			cout << i << " : " << data[i] << "는 홀수 입니다." << endl;
	}
	// 홀수와 짝수 차이를 구별해본다면 2로 나누었을때 나머지 값이 남는지 or 남지 않는지 구별하여 분리하도록 구해낼 수 있다.

		
	return 0; 
}
*/
// ──────────────────────────────────────────038 조건 순환문 1. while~ continue ~ break ──────────────────────────────────────────
int main() {
	int number = 0;
	// number를 증가시키기 위해 while에 10보다 작을때 계속 시행시키도록 (무한루프임)

	// 그 안에서 if문을 통해 number값이 3의 배수라면 (%3 나머지값이 0일때 3배수 넘어가도록) 출력이 수행되지 않도록
	while (number < 10) {
		number++;
		if (number % 3 == 0)
			continue;
		else
			cout << "number 값 : " << number << endl;
	
	}
	
	return 0;
}
